; ***************************************** ZEROPAGE **********************************************
!addr	zp	= $00		; zeropage start
; $24 - $2b reserved for wozmon
!addr xaml	= $24		; target address for "run", or start of hex dump
!addr xamh	= $25
; IEC zp
!addr	fnadr	= $d0 ; 2by	; Address of file name string
!addr	sal	= $d2		; Current load/store address
!addr	sah	= $d3		;   low, high
!addr	eal	= $d4		; End of load/save
!addr	eah	= $d5		;   low, high
!addr	stal	= $d6		; Start of load/save
!addr	stah	= $d7		;   low, high
!addr	status	= $db		; I/O operation status
!addr	fnlen	= $dc		; File name length
!addr	la	= $dd		; Current logical index
!addr	fa	= $de		; Current first address
!addr	sa	= $df		; Current secondary address
!addr	dfltn	= $e0		; Default input device
!addr	dflto	= $e1		; Default output device
!addr	relsal	= $e2		; moveable start load address
!addr	relsah	= $e3		;   low, high
!addr	relsab	= $e4		;   bank
!addr	c3p0	= $e5		; IEC buffer flag
!addr	r2d2	= $e6		; IEC serial bus usage eoi / jiffy device
!addr	lastchr	= $e7		; Interpreter: last char 
!addr	bsour	= $e8		; IEC character buffer 
!addr	bsour1	= $e8		; IEC character input
!addr	sxreg	= $e9		; Monitor: temp xreg, div
!addr	count	= $ea		; IEC bit counter / Monitor: assembler
!if JIFFY = 1{
!addr	jdtemp	= $eb		; JIFFY DOS temp (only used in jdload)
}
; Interpreter
!addr	tmp0	= $ec ; 2by	; Temp pointer
!addr	tmp1	= $ee 		; Temp
!addr	verck	= $ef		; load/verify flag
!addr	savx	= $f0		; temp
!addr	rambank	= $f1		; RAM bank
!addr	oldbank	= $f2		; stores old RAM bank
!addr	inpt	= $f3		; input buffer pointer
!addr	ddisk	= $f4		; Default disk unit # for monitor/basic
!addr	iecinit	= $f5		; =cf after first iec init (protects ddisk)
!addr	hulp	= $f6 ; 10by	; Eval working register
; ***************************************** ABSOLUTE **********************************************
!addr	stack	= $0100		; Stack
!addr 	in	= $0200		; text input buffer ($200-$27F)
; **************************************** ADDRESSES **********************************************
; PIA port A keyboard
!addr 	kbd	= $d010		; read key
!addr 	kbdcr	= $d011		; control port
; PIA port B display
!addr 	dsp	= $d012		; write ascii
!addr 	dspcr	= $d013		; control port
; 6522 VIA - MMU, IEC, User-Port
!addr 	via	= $d000
	; pa0: RAM bank bit #0
	; pa1: RAM bank bit #1
	; pa2: unused
	; pa3: IEC atn out
	; pa4: IEC clk out
	; pa5: IEC data out
	; pa6: IEC clk in
	; pa7: IEC data in
	; pb:  User-Port 

; VIA register
	prb	= $0	; Port reg b
	prah	= $1	; Port reg a (with handshaking)
	ddrb	= $2	; Direction reg b
	ddra	= $3	; Direction reg a
	t1lo	= $4	; Timer 1 low  byte
	t1hi	= $5	; Timer 1 high byte
	t1ldlo	= $6	; Timer 1 low  byte to load
	t1ldhi	= $7	; Timer 1 high byte to load
	t2lo	= $8	; Timer 2 low  byte
	t2hi	= $9	; Timer 2 high byte
	sr	= $a	; shift register
	acr	= $b	; auxilary control register
	pcr	= $c	; peripheral control register
	ifr	= $d	; Interrupt flags register
	ier	= $e	; Interrupt enable register
	pra	= $f	; Port reg a
; ****************************************** WOZMON ***********************************************
!addr 	escape	= $ff1a		; escape back to monitor
!addr 	prbyte	= $ffdc		; print A as 2 hex digits
!addr 	echo	= $ffef		; print the ascii char in A to the display